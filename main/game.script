local C = require "main.constants"
local U = require "main.utils"
local M = require "main.match"
local S = require "main.storage"

local FLOW = require "ludobits.m.flow"

local checkingSingleGlyph = false
local swapping = false
local checkingGlyphs = false

function init(self)	
	msg.post(".", "acquire_input_focus")
	-- randomize and discard the first values as they may be always the same
	math.randomseed(os.time())
	math.random()
	math.random()
	math.random()

	M.newMatch()
end

function final(self)
	-- cleanup
	FLOW.stop()
end

function update(self, dt)
	-- keep the flows going
	FLOW.update(dt)
end

function on_message(self, message_id, message, sender)
	-- Add message-handling code here
	-- Remove this function if not needed
end

local function log(msg) 
	print(os.clock() .. ": " .. msg .. " inputDisabled=" .. tostring(isInputDisabled()))
end

-- callback after freezing a glyph
local function freezeGlyphCompletedP2()
	log("2 freeze completed")
	-- recheck for other matches, can happen after a board swapBoard
	-- pass back true so we will generate a new glyph
	checkMatchingGlyph(C.PLAYER2, true)
end

-- callback after freezing a glyph
local function freezeGlyphCompletedP1()
	log("1 freeze completed")
	-- recheck for other matches, can happen after a board swapBoard
	-- pass back true so we will generate a new glyph
	checkMatchingGlyph(C.PLAYER1, true)
end

-- returns the callback for the given player
local function getFreezeGlyphCompletedCallback(player)
	if(player == C.PLAYER1) then
		return freezeGlyphCompletedP1
	elseif(player == C.PLAYER2) then
		return freezeGlyphCompletedP2
	end
end

-- check for a match for the given player
-- anyFound is set after finding a match in the freeze completed callback
function checkMatchingGlyph(player, anyFound)
	log(player .. " check match")
	checkingSingleGlyph = true
	local glyph = M.getPlayers().getGlyph(player)
	local match = M.getBoard().checkMatchingGlyph(player, glyph)
	if(match ~= nil) then
		-- freeze the match on the board
		log(player .. " MATCH FOUND")
		M.getBoard().freezeGlyph(match, glyph, getFreezeGlyphCompletedCallback(player))
	else
		log(player .. " match not found")
		if(anyFound) then
			log(player .. " NEW GLYPH")
			M.newGlyph(player)
			-- recheck
			checkMatchingGlyph(player, false)
		else
			-- no match, no previous match -> end
			checkingSingleGlyph = false
		end
	end
end

local function isCheckingSingleGlyphOngoing()
	return not checkingSingleGlyph
end

--check for a match for both players
local function checkMatchingGlyphs()
	checkingGlyphs = true
	log("1-2 check match")
	-- execute the checks one after the other and not in paralles as it would happen without using FLOW
	FLOW.start(function()
		checkMatchingGlyph(C.PLAYER1)
		FLOW.until_true(isCheckingSingleGlyphOngoing)
		checkMatchingGlyph(C.PLAYER2)
		FLOW.until_true(isCheckingSingleGlyphOngoing)
		checkingGlyphs = false
		log("1-2 check match completed")
	end)
end

-- callback for the swap board
local function swapCompleted() 
	swapping = false
	log("swap completed")
end

function isSwapCompleted()
	return not swapping
end

--swap the board
local function swapBoard()
	log("SWAP --------------")
	swapping = true
	M.getBoard().swapBoard(swapCompleted)
end

function isInputDisabled()
	return checkingGlyphs or swapping
end

function checkingGlyphsCompleted()
	return not checkingGlyphs
end

function checkAndSwapFlow()
	checkMatchingGlyphs()
	FLOW.until_true(checkingGlyphsCompleted)
	if(M.isSwapTriggered()) then
		swapBoard()
		FLOW.until_true(isSwapCompleted)
		checkMatchingGlyphs()
		FLOW.until_true(checkingGlyphsCompleted)
	end
end

function on_input(self, action_id, action)
	if action_id == hash("touch") and action.pressed then
		if(isInputDisabled()) then
			return
		end
		local pos = U.getWorldPos(action)
		local tile = U.getTile(pos)
		if(M.getBoard().isOnBoard(tile)) then
			local cell = M.getBoard().getCell(tile)
			if(cell == nil) then
				-- empty cell
				currentPlayer = M.getNextPlayer()
				log(currentPlayer .. " orb placed")
				M.getBoard().setCell(tile, currentPlayer)
				FLOW.start(checkAndSwapFlow)
			end
		end
	end
end

function on_reload(self)
	-- Add reload-handling code here
	-- Remove this function if not needed
end

