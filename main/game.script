local C = require "main.constants"
local U = require "main.utils"
local M = require "main.match"
local S = require "main.storage"

local FLOW = require "ludobits.m.flow"

local inputEnabled = true
local checkingGlyphOngoing = false

function init(self)	
	msg.post(".", "acquire_input_focus")
	-- randomize and discard the first values as they may be always the same
	math.randomseed(os.time())
	math.random()
	math.random()
	math.random()

	M.newMatch()
end

function final(self)
	-- cleanup
	FLOW.stop()
end

function update(self, dt)
	-- keep the flows going
	FLOW.update(dt)
end

function on_message(self, message_id, message, sender)
	-- Add message-handling code here
	-- Remove this function if not needed
end

-- callback after freezing a glyph
local function freezeGlyphCompletedP2()
	-- recheck for other matches, can happen after a board swapBoard
	-- pass back true so we will generate a new glyph
	checkMatchingGlyph(C.PLAYER2, true)
end

-- callback after freezing a glyph
local function freezeGlyphCompletedP1()
	-- recheck for other matches, can happen after a board swapBoard
	-- pass back true so we will generate a new glyph
	checkMatchingGlyph(C.PLAYER1, true)
end

-- returns the callback for the given player
function getFreezeGlyphCompletedCallback(player)
	if(player == C.PLAYER1) then
		return freezeGlyphCompletedP1
	elseif(player == C.PLAYER2) then
		return freezeGlyphCompletedP2
	end
end

-- check for a match for the given player
-- anyFound is set after finding a match in the freeze completed callback
function checkMatchingGlyph(player, anyFound)
	print("check matching for player " .. player)
	inputEnabled = false
	checkingGlyphOngoing = true
	local glyph = M.getPlayers().getGlyph(player)
	local match = M.getBoard().checkMatchingGlyph(player, glyph)
	if(match ~= nil) then
		-- freeze the match on the board
		M.getBoard().freezeGlyph(match, glyph, getFreezeGlyphCompletedCallback(player))
	else
		if(anyFound) then
			M.newGlyph(player)
		end
		inputEnabled = true
		checkingGlyphOngoing = false
	end
end

function isCheckingGLyphCompleted()
	return not checkingGlyphOngoing
end

--check for a match for both players
function checkMatchingGlyphs()
	print("check matching")
	-- execute the checks one after the other and not in paralles as it would happen without using FLOW
	FLOW.start(function()
		checkMatchingGlyph(C.PLAYER1)
		FLOW.until_true(isCheckingGLyphCompleted)
		checkMatchingGlyph(C.PLAYER2)
	end)
end

-- callback for the swap board
local function swapCompleted() 
	print("swap completed")
	checkMatchingGlyphs()
end

--swap the board
local function swapBoard()
	print("swap")
	inputEnabled = false
	M.getBoard().swapBoard(swapCompleted)
end

function on_input(self, action_id, action)
	if(inputEnabled == false) then
		return
	end
	if action_id == hash("touch") and action.pressed then		
		local pos = U.getWorldPos(action)
		local tile = U.getTile(pos)
		if(M.getBoard().isOnBoard(tile)) then
			local cell = M.getBoard().getCell(tile)
			if(cell == nil) then
				currentPlayer = M.getNextPlayer()
				print("==== ORB PLACED player " .. currentPlayer)
				M.getBoard().setCell(tile, currentPlayer)
				checkMatchingGlyph(currentPlayer)			
				if(M.isSwapTriggered()) then
					swapBoard()
				end			
			end
		end	
	end
end

function on_reload(self)
	-- Add reload-handling code here
	-- Remove this function if not needed
end

