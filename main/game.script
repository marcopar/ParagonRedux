local CO = require "main.constants"
local UT = require "main.utils"
local MA = require "main.match"
local ST = require "main.storage"
local FL = require "ludobits.m.flow"

local checkingSingleGlyph = false
local swapping = false
local checkingGlyphs = false
local inputDisabled = false

function init(self)	
	msg.post(".", "acquire_input_focus")
end

function final(self)
	-- cleanup
	MA.resetState()
	FL.stop()
end

function update(self, dt)
	-- keep the flows going
	FL.update(dt)
end

function on_message(self, message_id, message, sender)
	if(message_id == hash(CO.MESSAGE_NEWGAME)) then
		MA.newMatch()
	end
	if(message_id == hash(CO.MESSAGE_RESUMEGAME)) then
		MA.loadGame()
	end
	if(message_id == hash(CO.MESSAGE_LOADSETTINGS)) then
		MA.loadSettings()
	end
end

-- callback after freezing a glyph
local function freezeGlyphCompletedP2()
	UT.log("2 freeze completed")
	-- recheck for other matches, can happen after a board swapBoard
	-- pass back true so we will generate a new glyph
	checkMatchingGlyph(CO.PLAYER2, true)
end

-- callback after freezing a glyph
local function freezeGlyphCompletedP1()
	UT.log("1 freeze completed")
	-- recheck for other matches, can happen after a board swapBoard
	-- pass back true so we will generate a new glyph
	checkMatchingGlyph(CO.PLAYER1, true)
end

-- returns the callback for the given player
local function getFreezeGlyphCompletedCallback(player)
	if(player == CO.PLAYER1) then
		return freezeGlyphCompletedP1
	elseif(player == CO.PLAYER2) then
		return freezeGlyphCompletedP2
	end
end

-- check for a match for the given player
-- anyFound is set after finding a match in the freeze completed callback
function checkMatchingGlyph(player, anyFound)
	UT.log(player .. " check match")
	checkingSingleGlyph = true
	local glyph = MA.getPlayers().getGlyph(player)
	local match = MA.getBoard().checkMatchingGlyph(player, glyph)
	if(match ~= nil) then
		-- freeze the match on the board
		UT.log(player .. " MATCH FOUND")
		MA.getBoard().setGlyphCompleted(match, glyph, MA.isMarathon(), getFreezeGlyphCompletedCallback(player))
	else
		UT.log(player .. " match not found")
		if(anyFound) then
			UT.log(player .. " NEW GLYPH")
			MA.newGlyph(player)
			-- recheck
			checkMatchingGlyph(player, false)
		else
			-- no match, no previous match -> end
			checkingSingleGlyph = false
		end
	end
end

local function isCheckingSingleGlyphOngoing()
	return not checkingSingleGlyph
end

--check for a match for both players
local function checkMatchingGlyphs()
	checkingGlyphs = true
	UT.log("1-2 check match")
	-- execute the checks one after the other and not in paralles as it would happen without using FLOW
	FL.start(function()
		checkMatchingGlyph(CO.PLAYER1)
		FL.until_true(isCheckingSingleGlyphOngoing)
		checkMatchingGlyph(CO.PLAYER2)
		FL.until_true(isCheckingSingleGlyphOngoing)
		checkingGlyphs = false
		UT.log("1-2 check match completed")
	end)
end

-- callback for the swap board
local function swapCompleted() 
	swapping = false
	UT.log("swap completed")
end

function isSwapCompleted()
	return not swapping
end

--swap the board
local function swapBoard()
	UT.log("SWAP --------------")
	swapping = true
	MA.getBoard().swapBoard(swapCompleted)
end

function isInputDisabled()
	return inputDisabled
end

function checkingGlyphsCompleted()
	return not checkingGlyphs
end

function checkAndSwapFlow()
	checkMatchingGlyphs()
	FL.until_true(checkingGlyphsCompleted)
	if(MA.isSwapTriggered()) then
		swapBoard()
		FL.until_true(isSwapCompleted)
		checkMatchingGlyphs()
		FL.until_true(checkingGlyphsCompleted)
	end
	MA.setCurrentPlayer(MA.getNextPlayer())
	MA.saveGame()
	inputDisabled = false
end

local function processPlayerInput(currentPlayer, tile)
	inputDisabled = true
	if(MA.getBoard().isOnBoard(tile)) then
		local cell = MA.getBoard().getCell(tile)
		if(cell == nil) then
			-- empty cell
			UT.log(currentPlayer .. " orb placed")
			MA.getBoard().setCell(tile, currentPlayer)
			-- input reenabled inside the flow
			FL.start(checkAndSwapFlow)
		else
			inputDisabled = false
		end			
	else
		inputDisabled = false
	end
end

function on_input(self, action_id, action)
	if action_id == hash("touch") and action.pressed then
		if(isInputDisabled()) then
			return
		end
		if(MA.getPlayers().getType(MA.getCurrentPlayer()) ~= CO.SETTINGS_PLAYER_TYPE_HUMAN) then
			return
		end
		local x = action.screen_x
		local y = action.screen_y
		local pos = UT.getWorldPos(x, y)
		local tile = UT.getTile(pos)
		if(MA.getBoard().isOnBoard(tile)) then
			currentPlayer = MA.getCurrentPlayer()
			processPlayerInput(currentPlayer, tile)
		end
	end
end

function on_reload(self)
	-- Add reload-handling code here
	-- Remove this function if not needed
end

