local CO = require "main.constants"
local UT = require "main.utils"
local MA = require "main.match"
local ST = require "main.storage"

local FL = require "ludobits.m.flow"

local checkingSingleGlyph = false
local swapping = false
local checkingGlyphs = false
local inputDisabled = false

function init(self)	
	msg.post(".", "acquire_input_focus")
	msg.post("#", "show_first_screen")
	-- randomize and discard the first values as they may be always be the same
	math.randomseed(os.time())
	math.random()
	math.random()
	math.random()

	MA.newMatch()
end

function final(self)
	-- cleanup
	FL.stop()
end

function update(self, dt)
	-- keep the flows going
	FL.update(dt)
end

function on_message(self, message_id, message, sender)
	if(message_id == hash(CO.MESSAGE_NEWGAME)) then
		MA.newMatch()
	end
end

local function log(msg) 
	print(os.clock() .. ": " .. msg .. " inputDisabled=" .. tostring(isInputDisabled()))
end

-- callback after freezing a glyph
local function freezeGlyphCompletedP2()
	log("2 freeze completed")
	-- recheck for other matches, can happen after a board swapBoard
	-- pass back true so we will generate a new glyph
	checkMatchingGlyph(CO.PLAYER2, true)
end

-- callback after freezing a glyph
local function freezeGlyphCompletedP1()
	log("1 freeze completed")
	-- recheck for other matches, can happen after a board swapBoard
	-- pass back true so we will generate a new glyph
	checkMatchingGlyph(CO.PLAYER1, true)
end

-- returns the callback for the given player
local function getFreezeGlyphCompletedCallback(player)
	if(player == CO.PLAYER1) then
		return freezeGlyphCompletedP1
	elseif(player == CO.PLAYER2) then
		return freezeGlyphCompletedP2
	end
end

-- check for a match for the given player
-- anyFound is set after finding a match in the freeze completed callback
function checkMatchingGlyph(player, anyFound)
	log(player .. " check match")
	checkingSingleGlyph = true
	local glyph = MA.getPlayers().getGlyph(player)
	local match = MA.getBoard().checkMatchingGlyph(player, glyph)
	if(match ~= nil) then
		-- freeze the match on the board
		log(player .. " MATCH FOUND")
		MA.getBoard().freezeGlyph(match, glyph, getFreezeGlyphCompletedCallback(player))
	else
		log(player .. " match not found")
		if(anyFound) then
			log(player .. " NEW GLYPH")
			MA.newGlyph(player)
			-- recheck
			checkMatchingGlyph(player, false)
		else
			-- no match, no previous match -> end
			checkingSingleGlyph = false
		end
	end
end

local function isCheckingSingleGlyphOngoing()
	return not checkingSingleGlyph
end

--check for a match for both players
local function checkMatchingGlyphs()
	checkingGlyphs = true
	log("1-2 check match")
	-- execute the checks one after the other and not in paralles as it would happen without using FLOW
	FL.start(function()
		checkMatchingGlyph(CO.PLAYER1)
		FL.until_true(isCheckingSingleGlyphOngoing)
		checkMatchingGlyph(CO.PLAYER2)
		FL.until_true(isCheckingSingleGlyphOngoing)
		checkingGlyphs = false
		log("1-2 check match completed")
	end)
end

-- callback for the swap board
local function swapCompleted() 
	swapping = false
	log("swap completed")
end

function isSwapCompleted()
	return not swapping
end

--swap the board
local function swapBoard()
	log("SWAP --------------")
	swapping = true
	MA.getBoard().swapBoard(swapCompleted)
end

function isInputDisabled()
	return inputDisabled
end

function checkingGlyphsCompleted()
	return not checkingGlyphs
end

function checkAndSwapFlow()
	checkMatchingGlyphs()
	FL.until_true(checkingGlyphsCompleted)
	if(MA.isSwapTriggered()) then
		swapBoard()
		FL.until_true(isSwapCompleted)
		checkMatchingGlyphs()
		FL.until_true(checkingGlyphsCompleted)
	end
	inputDisabled = false
end

function on_input(self, action_id, action)
	if action_id == hash("touch") and action.pressed then
		if(isInputDisabled()) then
			return
		end
		inputDisabled = true
		local pos = UT.getWorldPos(action)
		local tile = UT.getTile(pos)
		if(MA.getBoard().isOnBoard(tile)) then
			local cell = MA.getBoard().getCell(tile)
			if(cell == nil) then
				-- empty cell
				currentPlayer = MA.getNextPlayer()
				log(currentPlayer .. " orb placed")
				MA.getBoard().setCell(tile, currentPlayer)
				-- input reenabled inside the flow
				FL.start(checkAndSwapFlow)
			else
				inputDisabled = false
			end
		else
			inputDisabled = false
		end
	end
end

function on_reload(self)
	-- Add reload-handling code here
	-- Remove this function if not needed
end

